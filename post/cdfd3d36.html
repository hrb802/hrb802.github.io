<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机数据库（个人备考） | 灯三千的个人小天地</title><meta name="author" content="Brihen"><meta name="copyright" content="Brihen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="个人备考计算机数据库的相关内容">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机数据库（个人备考）">
<meta property="og:url" content="https://hrb802.github.io/post/cdfd3d36.html">
<meta property="og:site_name" content="灯三千的个人小天地">
<meta property="og:description" content="个人备考计算机数据库的相关内容">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hrb802.github.io/img/Chuyin.png">
<meta property="article:published_time" content="2025-06-22T08:04:14.000Z">
<meta property="article:modified_time" content="2025-07-09T10:42:33.877Z">
<meta property="article:author" content="Brihen">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hrb802.github.io/img/Chuyin.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算机数据库（个人备考）",
  "url": "https://hrb802.github.io/post/cdfd3d36.html",
  "image": "https://hrb802.github.io/img/Chuyin.png",
  "datePublished": "2025-06-22T08:04:14.000Z",
  "dateModified": "2025-07-09T10:42:33.877Z",
  "author": [
    {
      "@type": "Person",
      "name": "Brihen",
      "url": "https://hrb802.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/Myfavicon.png"><link rel="canonical" href="https://hrb802.github.io/post/cdfd3d36.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机数据库（个人备考）',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/ProfilePic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/search/"><i class="fa-fw fas fa-search"></i><span> 搜索</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/bangumi/"><i class="fa-fw fas fa-tv"></i><span> 番剧</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/Chuyin.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">灯三千的个人小天地</span></a><a class="nav-page-title" href="/"><span class="site-name">计算机数据库（个人备考）</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/search/"><i class="fa-fw fas fa-search"></i><span> 搜索</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/bangumi/"><i class="fa-fw fas fa-tv"></i><span> 番剧</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">计算机数据库（个人备考）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-22T08:04:14.000Z" title="发表于 2025-06-22 16:04:14">2025-06-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-09T10:42:33.877Z" title="更新于 2025-07-09 18:42:33">2025-07-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">学习记录</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">19.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>DBMS 数据库管理系统    DBAS 数据库应用系统    DBA数据库管理员</p>
<h2 id="数据库分析与设计"><a href="#数据库分析与设计" class="headerlink" title="数据库分析与设计"></a>数据库分析与设计</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>需求分析具体包括数据需求分析、功能需求分析、性能需求分析、其他需求分析（数据存储需求分析、安全性需求分析、备份和恢复需求分析）</p>
<p>允许并发访问的最大用户数，是指在保证单个用户查询相应时间的前提下，系统最多允许多少用户同时访问数据库。系统性能越强，允许的用户数量就越多。</p>
<p>DBMS需求分析阶段的性能分析是分析DBMS应该具有的性能指标</p>
<p>属于DBMS性能指标的是：数据查询响应时间、单位时间内可以完成的查询数量、单位时间内可以完成的事务数量</p>
<p>DBAS实施阶段工作：创建数据库、装载数据、编写与调试应用程序、数据库试运行</p>
<p>数据库运行维护与优化的工作：数据库性能调优、数据转储、系统监控</p>
<p>属于DBAS实施与部署工作：数据加载、系统部署、建立数据库（无规范化表结构）</p>
<p>从功能角度DBAS分为四个层次：</p>
<p>表示层：负责用户交互，即用户界面</p>
<p>业务逻辑层：梳理DBAS各项业务活动，将其表示为各种系统构建，核心业务逻辑在本层实现。</p>
<p>数据访问层：使用事件进行信息交换。</p>
<p>数据持久层：保存和管理应用系统数据</p>
<p>数据库应用系统（DBAS）实现与部署内容包括：</p>
<p>建立数据库结构<br>数据加载<br>事务和应用程序的编码及测试<br>系统集成、测试与运行<br>系统部署<br>事务详细编码设计实在实现与部署阶段完成的</p>
<p>从功能角度数据库应用系统可以划分为：</p>
<p>数据持久层：负责保存和管理应用系统数据</p>
<p>表示层：用于显示数据和接收用户输入的数据（一般为Windows应用程序或web应用程序）</p>
<p>数据访问层：负责与DBMS系统进行交互，提取或存入应用系统所需的数据</p>
<p>业务逻辑层：是表示层和数据访问层之间的桥梁，主要负责数据的传递和处理</p>
<p>构件属于其中的业务逻辑层</p>
<p>在数据库应用系统生命周期中，进行项目的成本估算属于项目规划</p>
<h3 id="IDEF0需求建模方法"><a href="#IDEF0需求建模方法" class="headerlink" title="IDEF0需求建模方法"></a>IDEF0需求建模方法</h3><p>描述功能活动示意图中矩形框代表功能活动，写在矩形框内的动词短语描述功能活动的名称，活动的编号按照要求写在矩形框右下角指定的位置。</p>
<p>左边的输入箭头表示完成活动需要的数据；</p>
<p>右边的输出箭头说明由活动产生的结果及信息，</p>
<p>矩形框上方的控制箭头描述了影响这个活动执行的事件或约束条件；</p>
<p>下方进入的机制箭头表示实施该活动的物理手段或完成活动需要的资源（计算机系统、人或组织）。</p>
<p>IDEF1X是一种数据建模方法，主要用于概念模型的设计，能够更精确的描述数据的结构和语义</p>
<p>在IDEF1X中，如果实体集的一个实例的唯一标识依赖于该实体集与其他实体集的联系，那么他就是从属标识符实体集或简称为从属实体集。</p>
<p>IDEF1X用矩形框来表示独立实体集，用加了圆角的矩形框来表示从属实体集。</p>
<p>从属实体集可以参与标定型联系，但不仅限于此，还可以参与非标定型联系，分类联系和非确定联系。</p>
<p>独立实体集与从属实体集语法：</p>
<p>IDEF1X侧重分析、抽象和概括应用领域中的数据需求，被称为数据建模方法</p>
<p>UML,DFD,IDEF0属于分析建模方法</p>
<p>IDEF1X数据建模方法中，老师和学生之间的一对多“导师”联系属于——非标定型联系</p>
<p>在IDEF1X数据建模方法中，联系被分为多种类型。其中，非标定型联系（A）指的是一种联系，其一方实体（如学生）通过该联系可以关联到另一方实体（如老师）的多个实例，但这种关联不是通过主键或唯一标识符来确定的。在本题中，老师和学生之间的一对多“导师”联系正符合这种描述，即一个老师可以指导多个学生，但学生选择导师并不是通过某个唯一标识符来确定的。</p>
<p>IDEF1X中，如果实体集的一个实例的唯一标识依赖于该实体集与其他实体集的联系，那么他就是从属标识符实体集或简称为从属实体集</p>
<p>如果子女实体集中的每一个实例都能被唯一的确认而无需了解与之相联系的双亲实体集的实例，该联系就被称为“非标定型联系”，不会产生从属实体集。</p>
<p>一个非确定联系又称为“多对多关系”，这种联系关联的两个实体集之间，任一实体集的一个实例都将对应另一个实体集的0个、1个或多个实例。</p>
<p>数据流图必须是正确的、一致的</p>
<p>在数据流图中，一个处理至少有一个输入流和一个输出流，并不是唯一的。</p>
<h3 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h3><p>在进行数据库设计时，考虑到应用主要以分析型查询为主，决定对表采取按列存储的实施方案，这一操作属于数据库的物理结构设计</p>
<p>数据库物理设计的目的是将数据的逻辑描述转换为实现技术规范，其目标是设计数据存储方案，以便提供足够好的性能并确保数据库数据的完整性、安全性和可恢复性</p>
<p>对关系模式进行去规范化处理，属于数据库结构设计中的物理结构设计。</p>
<p>数据库物理设计阶段主要关注如何在物理上存储数据库的结构，包括表的组织、索引的建立、分区的策略等，以优化数据库的性能和存储效率。</p>
<h3 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h3><p>数据库逻辑设计的目的是得到实际的数据库管理系统可处理的数据库模式，各模式结构合理，数据之间不存在不合理的数据依赖关系，且满足各类应用的处理和使用需求，为数据库的物理设计及数据库高校，正确地允许打下基础。</p>
<p>关系模式的设计、规范化处理属于数据库逻辑结构设计的内容</p>
<p>创建新的索引属于数据库应用系统优化内容</p>
<p>属于数据库应用系统升级工作的是：改变数据库应用系统体系结构，升级DBMS版本，修改程序以适应新的需求</p>
<p>系统规划与定义的内容包括：任务陈述、确定任务目标、确定系统范围和边界、确定用户视图。</p>
<p>可行性分析阶段的任务包括技术可行性、经济可行性、操作可行性、开发方案选择</p>
<p>索引使用原则：</p>
<p>经常在查询中作为条件被使用的列<br>频繁进行排序或者分组（进行group by 或 order by 操作）的列<br>一个列的值域很大，如果待排序的列有多个，应该在这些列上建立符合索引<br>Select后面出现的查询属性通常是返回结果字段，而不是用来排序或过滤的字段。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在编写事务时，提高事务的隔离性级别带来的好处是——降低了发生数据不一致的可能性</p>
<p>事务的隔离性是指多个并发事务同时访问一个数据库时，一个事务不应该被另一个事务所干扰，即保证并发读取数据的正确性，降低发生数据不一致的可能性</p>
<p>降低事务隔离级别可以：</p>
<p>提高事务吞吐量</p>
<p>提高活锁的可能性</p>
<p>降低发生死锁的可能性</p>
<p>降低发生阻塞的可能性</p>
<p>事务中为了降低死锁发生的可能，通常考虑：</p>
<p>按同意顺序访问资源</p>
<p>避免事务中的用户交互</p>
<p>采用小事务模式</p>
<p>尽量缩短事务的长度</p>
<p>减少占有锁的时间</p>
<p>尽量使用记录级别的锁（行锁）少使用表级别的锁</p>
<p>使用绑定连接，是同一应用程序所打开的两个或多个连接可以相互合作</p>
<p>多个小事务合并成大事务，会增加占有锁的时间，可能会造成大量阻塞事务，甚至会产生死锁。</p>
<p>数据处理需求分析结果也可以表示为事务规范</p>
<p>事务规范包括事务名称、事务描述、事务所访问的数据项、事务用户</p>
<p>事务隔离级别不属于事务规范</p>
<p>事务的并发访问可以提高吞吐量，并发控制常用的是封锁技术，其设计原则是：</p>
<p>按同一顺序访问资源</p>
<p>避免事务中的用户交互</p>
<p>采用小事务模式</p>
<p>尽量使用记录级别的锁（行锁），少用表级别的锁（使用行锁代替表级锁）</p>
<p>使用绑定连接</p>
<p>事务概要设计内容包括：事务名称、事务所访问的关系表及关系属性、事务处理逻辑、事务用户（指使用、启动、调用该事务的软件模块或系统）</p>
<h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><p>完整性约束条件的作用对象分为：列、元组和关系三种级别</p>
<p>对列的约束主要指：对其值类型、范围、精度、排序等的约束条件</p>
<p>对元组的约束主要指：对记录中各个属性之间的联系的约束条件</p>
<p>对关系的约束是指：对若干记录间、关系集合上以及关系之间联系的约束条件</p>
<p>数据完整性约束是指保证数据的准确性和一致性的规则</p>
<p>列级完整性约束： 仅作用于单个列，如数据类型、格式和值范围等</p>
<p>元组级完整性约束： 作用于关系表中的单个元组，如唯一性约束等</p>
<p>关系级完整性约束： 作用于整个关系表，如实体完整性和参照完整性等</p>
<p>数据库级完整性约束： 涉及多个关系表之间的关联和一致性</p>
<p>Unique 唯一索引</p>
<p>Clustered 聚集索引</p>
<h2 id="UML与数据库应用系统-UML（统一建模语言）"><a href="#UML与数据库应用系统-UML（统一建模语言）" class="headerlink" title="UML与数据库应用系统 UML（统一建模语言）"></a>UML与数据库应用系统 UML（统一建模语言）</h2><p>UML（同一建模语言）的建模概念架构包括元元模型层、元模型层、模型层和用户模型四个层次</p>
<p>元元模型层： UML的最高层次，定义了最基本的元素“事物”，是UML的基础</p>
<p>元模型层：这一层的每个概念都是元元模型层中“事物：概念的一个实例</p>
<p>模型层：这一层中的每个概念都是元模型层的一个实例</p>
<p>用户模型层： 这一层中的每个概念都是模型层的一个实例</p>
<p>在UML中，椭圆代表用例，位于系统边界内部</p>
<p>用例之间包括扩展、使用、组合三种关系</p>
<p>DBAS系统内部结构的表达：UML中，用类图来描述系统的静态结构，而用顺序图和通信图来表示系统的动态结构</p>
<p>数据库应用系统内部结构一般分为静态结构与动态结构，</p>
<p>通信图与顺序图都是交互图，从不同的侧面描述系统的动态结构，顺序图强调的是时间，通信图强调的是空间</p>
<p>顺序图主要用于描述系统内对象之间的消息发送与接收序列，其主要目的是表达对象与对象之间沟通与合作的方式，属于系统的动态模型</p>
<p>通信图也称为协作图，用于表示对象之间的联系以及对象间发送和接收的消息</p>
<p>类图主要表达的是问题领域的概念模型，用于表达抽象概念的名臣、属性、行为及关系等系统中的静态结构</p>
<p>UML（统一建模语言）进行系统建模过程中，系统内部结构通常分为静态结构和动态结构，不同类型的图用于描述不同的方面  </p>
<p>类图： 用于描述系统内部的静态结构，主要展示系统中的类及其之间的关系，表达问题领域的概念模型</p>
<p>顺序图： 用于描述系统内部的动态结构，主要用于展示系统内对象之间的消息发送与接收序列，显示对象之间的交互顺序</p>
<p>通信图： 也称为协作图 用于描述系统内部的动态结构，展示对象之间的联系以及对象间发送和接收的消息</p>
<p>用例模型： 用于描述系统的功能需求，从外部执行者的角度看系统的功能，但并不涉及系统内部的具体实现细节</p>
<p>用例模型的构成元素</p>
<p>用例模型是用于表示系统功能需求的工具，主要由用例、角色和系统三部分构成</p>
<ol>
<li><p>角色是与系统进行交互的外部实体，可以是系统用户、其他系统或硬件设备，而不是系统内部的实体。角色代表了系统外部的参与者，他们与系统进行交互以完成某些任务或操作</p>
</li>
<li><p>用例用于描述从系统用户的角度来观察系统应具有的功能，帮助分析人员理解系统的行为和功能需求</p>
</li>
<li><p>系统用于抽象的表示能够实现的所有基本功能，是用例模型的核心部分，展示了系统应具备的功能和行为</p>
</li>
<li><p>一个角色可以执行多个用例，一个用例也可以被多个角色使用，这说明角色和用例之间存在多对多的关系</p>
</li>
</ol>
<p>DB文字组织与存取设计的步骤是 ：</p>
<p>使用事务-基本表交叉引用矩阵，分析系统内数据库事务对各个基本表的访问情况；估计各事务的执行频率；对每张基本表，汇总所有作用于该表上的各事物的操作频率信息；根据分析结果，对基本表设计成更为有效的文件组织和索引方式</p>
<p>在UML中，系统的微观设计可用对象状态机图和时间图从不同的侧面进行表达</p>
<p>对象图主要用于解释类图以及验证所设计的类图是否符合实际状况，可也用于协助程序设计人员理解复杂的类图结构，对象图可以看成是系统在某一时间点的快照，用于描述特定时间点上所有对象在系统中的结构</p>
<p>一般情况下，时间图作为状态机图的辅助说明工具，一张时间图通常会对应至少一张状态图</p>
<h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><p>DESC 降序          ASC升序</p>
<p>使用FOR（for）或者AFTER（after）选项定义的触发器为后触发型触发器，即只有在引发触发器执行的语句中的操作都已成功执行，并且所有的约束检查也成功完成后，才执行该触发器。</p>
<p>使用INSTEAD OF（instead of） 选项定义的触发器为前触发型触发器，在这种模式的触发器中，指定触发器而不是执行引发触发器执行的SQL语句，从而替代触发的操作</p>
<p>创建索引的简化语法格式：</p>
<p>CREATE [UNIQUE] [CLUSTERED|NONCLUSTERED] INDEX index_name</p>
<p>ON <object>(column [ASC|DESC])</p>
<p>Column:索引所基于的一个列或多个列。如果指定多个列名，则可为指定列的组合值创建组合索引。</p>
<p>唯一索引可以确保索引列不包含重复的值。在多列唯一索引的情况下，可以确保索引列中每个值的组合都是唯一的。</p>
<h4 id="创建分区函数的sql语句是："><a href="#创建分区函数的sql语句是：" class="headerlink" title="创建分区函数的sql语句是："></a>创建分区函数的sql语句是：</h4><p>CREATE PARTITION FUNCTION partition_function_name(input_parameter_type)</p>
<p>AS RANGE [LEFT|RIGHT]</p>
<p>FOR VALUES([boundary_value[…,…n])</p>
<p>partition_function_name：分区函数的名称。 分区函数名称在数据库内必须唯一，并且符合标识符的规则。</p>
<p>input_parameter_type：用于分区的列的数据类型。 当用作分区列时，除 text、ntext、image、xml、timestamp、varchar(max)、nvarchar(max)、varbinary(max)、别名数据类型或 CLR 用户定义数据类型外，所有数据类型均有效。</p>
<p>boundary_value：为使用 partition_function_name 的已分区表或索引的每个分区指定边界值。 如果 boundary_value 为空，则分区函数使 partition_function_name 将整个表或索引映射到单个分区。 只能使用 CREATE TABLE 或 CREATE INDEX 语句中指定的一个分区列。</p>
<p>LEFT | RIGHT 指定当间隔值由 数据库引擎 按升序从左到右排序时，boundary_value [ ,…n ] 属于每个边界值间隔的哪一侧（左侧还是右侧）。 如果未指定，则默认值为 LEFT。</p>
<h2 id="数据库后台编程技术"><a href="#数据库后台编程技术" class="headerlink" title="数据库后台编程技术"></a>数据库后台编程技术</h2><p>存储的好处是：允许模块化程序设计、改善性能、减少网络流量、增强应用程序的安全性</p>
<p>所谓存储过程，实际上是存储在数据库中供用户程序调用的子程序</p>
<p>存储过程是程序，可实现但不限于数据查询。</p>
<p>存储过程时存储在数据库服务器端的可以被调用执行的代码</p>
<p>存储过程可以有多个输入和输出参数，参数类型随意</p>
<p>存储过程是调用执行的、存储在服务器端的代码段</p>
<p>利用存储过程可以提高数据操作性能</p>
<p>存储过程可以接受多个输入参数，也可以接受多个输出参数</p>
<p>利用存储过程可以提升数据的安全性</p>
<p>存储过程的返回结果可以是一个集合</p>
<p>利用存储过程可以进行模块化程序设计</p>
<p>存储过程可以接受多个输入参数，并可返回多个输出结果</p>
<p>存储过程，实际上是存储在数据库中供所有用户调用的子程序</p>
<p>在调用存储过程时，只需要声明参数的类型，不能指明参数为输出参数。</p>
<p>只有再执行时才能指明参数为输出参数</p>
<p>在创建存储过程中可以声明一个或多个参数。</p>
<p>除非定义了参数的默认值或者将参数设置为等于另一个参数，否则用户在调用存储过程时必须为每个声明的参数提供值。</p>
<p>一个存储过程最多可以有2100个参数。一个存储过程可以有对各输出参数</p>
<p>删除存储过程的语句为:</p>
<p>DROP {PROC|PROCEDURE}{[shema_name.] procedure}[…,…n]</p>
<p>执行有多个输入参数的存储过程时，参数的传递方式有两种：</p>
<p>按参数位置传递值<br>按参数位置传递值指执行存储过程的EXEC语句中的实参的排列顺序必须与定义存储过程时定义的参数的顺序一致</p>
<p>按参数名传递值<br>按参数名传递值指的是执行存储过程的EXEC语句中要知名定义存储过程时指定的参数的名字以及此参数的值，而不关心参数的定义顺序</p>
<p>（看题目类型，盲猜一次出现一种传递方式）</p>
<p>收缩数据库就是释放数据库中未使用的空间，并将释放的空间交还给操作系统。数据文件和日志文件的空间都可以收缩。</p>
<p>For或after指的是后触发器，instead of 是前触发器。</p>
<p>Insert指的是引发触发器执行的操作是插入操作</p>
<p>Eg：设在SQL Server中有如下定义触发器的语句：</p>
<p>CREATE TRIGGER tri_1</p>
<p>ON T1 FOR INSERT</p>
<p>AS……</p>
<p>所以语句的功能是：在T1表上定义了一个由插入操作引发的后触发型触发器</p>
<p>使用instead of 选项定义的触发器是前触发器，在这种模式的触发器中，指定执行触发器而不是执行引发触发器执行的sql语句，从而替代触发的操作。在一个表上可以建立多个名称不同、类型各异的触发器，每个触发器可有所有三个操作来引发。</p>
<p>对于前触发器，在一个表上针对同一个数据操作只能定义一个前触发器，对于后触发器，可以在同一种操作上建立多个触发器</p>
<p>NEXT（next）（下一行）关键字的作用是返回紧跟在当前之后的数据行，并且当前行递增为结果行</p>
<p>PRIOR（prior）（前一行）关键字返回紧临当前行前面的数据行，并且当前行递减为结果行</p>
<p>ABSOLUTE n （绝对位置的第n行）和RELATIVE n （相对于当前位置第n行）关键字用于指定特定行</p>
<p>FIRST（第一行）关键字发那会游标中的第一行并将其作为当前行</p>
<p>LAST（最后一行）关键字返回游标中的最后一行并将其作为当前行</p>
<p>对象级授权命令中，视图权限中没有create权限，所以这里是语句级授权。</p>
<p>授予语句级别权限的GRANT语句的简化语法格式如下：</p>
<p>GRANT {ALL | <statement_permission>[,…n]}</p>
<pre><code>TO &lt;database_principal&gt;[,…n]
</code></pre>
<p>由语法可知，应选A，而不能选B（B选项是对象级授权命令）。</p>
<p>在SQL Server中，若要授予用户U1在DB1数据库中具有创建视图的权限，下列授权语句正确的是__A____。</p>
<p>A、GRANT CREATE VIEW TO U1</p>
<p>B、GRANT CREATE VIEW ON DB1 TO U1</p>
<p>C、GRANT U1 CREATE VIEW ON DB1</p>
<p>D、GRANT U1 CREATE VIEW</p>
<h2 id="数据库及数据库对象"><a href="#数据库及数据库对象" class="headerlink" title="数据库及数据库对象"></a>数据库及数据库对象</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>CREATE PARTITION FUNCTION myPF1(int)</p>
<p>AS RANGE LEFT FOR VALUES (1,100,1000);</p>
<p>LEFT —— 向左靠拢，分区为：&lt;&#x3D;1,(1,101],(101,1000],&gt;1000</p>
<p>现要创建将每个分区映射到不同文件组的分区方案，让前两个分区映射到fg1文件组中，</p>
<p>CREATE PARTITION SCHEME myPS1 AS PARTITION myPF1 TO (fg1, fg1,fg2,fg2)</p>
<p>创建分区表的步骤：</p>
<p>创建分区函数。创建分区函数的目的时告诉数据库管理系统以什么方式对表进行分区<br>创建分区方案。分区方案的作用时将分区函数生成的分区映射到文件组中<br>使用分区方案创建表。水平划分将一张基本表划分为多张具有相同属性、结构完全相同的子表。垂直划分则是将一张基本表划分为多张子表，每张子表包含的属性时原基本表的子集<br>分区表是将表中的数据按水平方式划分成不同的子集，这些数据子集存储在数据库的一个或多个文件组中。</p>
<p>分区表是从物理上将一个大表分成几个小表，但从逻辑上来看还是一个大表。对于用户而言，所面对的仍然是一个大表，用户只要对大表进行操作就可以，数据库管理系统会自动对小标进行操作。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是一种数据库对象，用于提高数据检索的效率</p>
<p>聚集索引：决定表中数据的物理顺序，每个表只能有一个聚集索引，因为数据只能按一个物理顺序存储</p>
<p>非聚集索引：类似于书籍的目录，数据存放在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。一个表可以有多个非聚集索引，非聚集索引不会影响到表中数据的物理存储顺序，他只是创建了一个指向数据的索引</p>
<p>唯一索引：可以是聚集的，也可以是非聚集的，确保索引列中的值是唯一的</p>
<p>索引的维护：当对表中的数据进行增加、删除和修改时，索引也需要动态维护，这会降低数据的维护速度，建立索引会增加数据的检索速度，但一般会降低数据的增删改效率，因为需要同步维护索引</p>
<p>在表上建立聚集索引后，系统将对表中数据按聚集索引键值进行物理排序</p>
<p>如果数据文件中的数据记录的排列顺序与索引文件中索引项的排列顺序一致，那么该索引文件就成为聚集索引</p>
<p>由于数据文件中的数据可能存在相同的值，所以聚集索引必然不是唯一索引。</p>
<p>一个数据文件可以建立一个聚集索引，以及多个非聚集索引</p>
<p>唯一索引的作用是保证索引键值的不重复，在多列唯一索引的情况下，可以确保索引中每个值的组合都是唯一的。唯一索引和非聚集索引之间没有限定关系</p>
<p>唯一索引不允许两行具有相同的索引键值。</p>
<p>聚集索引键值的逻辑顺序决定表中对应行的物理顺序。一个表或视图只允许同时有一个聚集索引</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>日志文件是独立管理的，不包括在文件组内，因此不能为日志文件单独定义文件组</p>
<p>次要数据文件.ndf和主要数据文件.mdf可以位于同一文件组，便于管理和分配存储</p>
<p>用户可以自行指定数据文件和日志文件的存放位置</p>
<p>次要数据文件可以与主要数据文件存放在不同位置</p>
<p>数据库所包含的文件与文件存储位置信息均保存在主要数据文件</p>
<p>正被用户访问的数据库不能被分离，分离数据库的操作需要暂停服务，不需要暂停SQL Server服务</p>
<p>Tempdb是临时数据库，用于保存临时对象或中间结果集，并为数据的排列等操作提供一个临时工作空间，每次启动SQL Server时都会重新创建tempdb数据库</p>
<p>架构（Schema，也称作模式）是数据库下的一个逻辑命名空间，可以存放表、视图等数据库对象，一个数据库可以包含一个或多个架构，不同的架构中，数据库对象可以重名，架构由特定的授权用户所拥有</p>
<p>在同一个数据库中，架构名必须唯一，架构名可以是显示的，也可以由DBMS提供默认名。</p>
<h2 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h2><p>收回用户权限 remove</p>
<p>Remove 权限名 on 对象名 from 用户</p>
<p>授予用户权限 grant</p>
<p>Grant 权限 to 用户</p>
<p>Grant 权限 on 数据库对象 to 用户</p>
<p>Eg：设SQL Server 2008某数据库中有表T1(c1, c2, c3)，并仅对U1执行了如下授权语句：</p>
<p>GRANT UPDATE ON T1 TO U1</p>
<p>现有下列数据操作语句：</p>
<p>Ⅰ. UPDATE T1 SET c1 &#x3D; 100</p>
<p>Ⅱ. UPDATE T1 SET c1 &#x3D; c1 + 100</p>
<p>Ⅲ. UPDATE T1 SET c1 &#x3D; c3 + c1</p>
<p>Ⅳ. UPDATE T1 SET c1 &#x3D; 100 WHERE c2 &#x3D; ‘A’</p>
<p>（在 UPDATE 中：SET 是定义列新值的核心关键字。）</p>
<p>上述语句中，U1有权执行的是      。</p>
<p>UPDATE权限允许修改表中的列，但若操作中需要读取其他列的值（通过WHERE子句或SET表达式），则需额外SELECT权限。</p>
<p>Grant update on T1 to U1语句的作用是用户U1具有对表T1各列数据进行修改的权利，在SQL server中，拥有update权限的用户并不意味着一定拥有select权限</p>
<p>GRANT CREATE TABLE ON DB1 TO U1</p>
<p>ON 子句用于指定对象（如表、视图），但此处 DB1 是数据库名，需使用 ON DATABASE::DB1 明确作用域。直接写 ON DB1 不符合语法规范。</p>
<p>错误。</p>
<p>Guest，不是一个登录账户，而是一个数据库角色，用于为用户提供访问权限，作为特殊用户，用于匿名访问权限</p>
<p>服务器级角色：定义在服务器级别，影响整个服务器的操作，例如dbcreator角色允许用户创建数据库</p>
<p>数据库级角色：这些角色定义在特定数据库中，仅影响该数据库的操作。db_datareader角色是数据库级角色，赋予成员对数据库中所有用户数据的读取权限</p>
<p>db_datawriter是固定数据库角色之一，具有插入和更改数据库中所有用户数据的权限</p>
<p>db_datareader仅允许查询用户数据，而不是系统数据</p>
<p>Oracle的安全控制机制可分为数据库级的安全控制、表级、行级、列级的安全控制</p>
<p>数据库级的安全性通过用户身份认证和授予用户相应系统权限来保证，而表级、行级、列级的安全性是通过授予或回收用户特权保证的。</p>
<p>Oracle数据库中的用户按其操作权限大小可分为DBA用户和普通用户。</p>
<p>SQL Server 2008的身份验证模式有“windows 身份验证模式”和“混合身份验证模式”（也称为“SQL server和windows身份验证模式”）两种。</p>
<p>Windows身份验证模式：只允许通过windows身份验证的用户登录</p>
<p>混合身份验证模式是指SQL Server 允许Windows授权用户和SQL授权用户登录到SQL Server数据库服务器</p>
<p>当登录账户称为数据库中的合法用户之后，该账户除了具有一些系统的查询权限之外，并不对数据库中的用户数据和对象具有任何操作权限，因此，下一步就需要为数据库中的用户授予数据库数据及对象的操作权限。</p>
<p>数据库管理员可以对数据库用户授权</p>
<p>角色是一组具有相同权限的用户的集合，用户定义的角色属于数据库一级的角色，用户定义的角色的成员可以是数据库的用户，也可以是用户定义的角色。只要权限没有被拒绝过，则角色中成员的权限就是其所在角色的权限上加上他们自己所具有的权限。</p>
<p>用户定义的数据库角色是指由用户自行创建的权限管理单元，用于在数据库级别进行权限分配和管理</p>
<p>一个数据库可以定义多个用户角色，即用户可以根据需要创建多个角色来管理不同用户的权限<br>一个用户定义的角色可以包含多个成员：一个角色可以包含多个用户或其他角色，从而进行权限的集中管理<br>可以为用户定义的角色进行授权：通过grant语句可以为用户定义的角色授予特定的权限<br>用户定义的角色可以是另一个用户定义角色的成员：一个用户定义的角色可以作为另一个用户定义角色的成员，从而实现更灵活的权限管理</p>
<h2 id="运行维护与优化"><a href="#运行维护与优化" class="headerlink" title="运行维护与优化"></a>运行维护与优化</h2><h3 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h3><p>数据库系统运行需要依赖服务器、操作系统、存储、网络等多种因素。单纯地增加数据库CPU数量并不一定会提高数据库查询速度。</p>
<p>RAID1提高了都速度，加强了系统的可靠性，但是磁盘的利用率低，冗余度高，写的速度并未提高。</p>
<p>数据库管理员啊进行优化时需要对数据库系统有深入了解，对业务系统也要深入了解</p>
<p>在数据库优化中，增加冗余列是一种常见的方法，通过在数据库中增加一些冗余数据来提高查询性能</p>
<p>减少聚合函数的使用：派生性冗余列可以通过存储聚合函数的结果来减少聚合函数的使用次数，从而提高查询效率<br>减少数据分组操作带来的资源消耗：增加冗余列可以减少数据分组操作，从而降低资源消耗<br>不符合第三范式要求：增加冗余列会导致数据重复，从而违反第三范式的要求<br>减少查询时的连接操作：增加冗余列不能减少查询时的连接操作，因为连接操作通常涉及多表间的关系，而增加冗余列主要针对的是减少聚合函数和分组操作<br>数据库性能优化会涉及到数据库的重组和重构。数据库的重组并不修改数据库原有设计的逻辑结构和物理结构，而数据库的重构则不同，它是指部分修改数据库的模式和内模式。</p>
<p>数据库性能优化对数据库管理员的要求比较高，调整一个数据库应用系统的性能要求熟悉系统环境、数据库管理系统、应用程序以及应用程序所使用的数据</p>
<p>在数据库调优过程中常见的方法包括：分割表、新增汇总表、增加派生冗余列和增加冗余列等 </p>
<p>分割表：将一个大表分成多个小表，以提高查询性能<br>新增汇总表：通过对原始数据进行汇总，生成一个新的表，以方便查询<br>增加派生冗余列：在表中增加一些通过计算得到的列，以减少查询时的计算量<br>增加冗余列：在表中增加一些重复的链，以减少查询时的连接操作</p>
<h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>水平分割是对一张表在水平方向分割，分割后得到得表结构相同，存储的数据不同，水平分割会增加复杂度，查询时需要使用UNION（并）运算，大部分是局部使用。</p>
<p>垂直分割则是对一张表在垂直方向分割，分割后每张表中除主码列外其他列均不同，查询时会减少I&#x2F;O次数，查询时需要使用JOIN（连接）运算</p>
<p>分割的目的是提高性能</p>
<p>在数据库设计阶段，主要强调的是高效率利用存储空间，减少数据的冗余，减少数据的不一致，这个过程也就是规范化的过程。规范化关系解决了数据维护的异常，并使冗余最小化，然而，可能出现数据处理性能下降的问题，在大多数情况下，数据库系统需要考虑的第二个目标是高效率的数据处理，反规范化处理，如增加派生冗余列，增加冗余列，重新组表，分割表和新增汇总表可以有效地提高查询效率</p>
<p>数据库设计初期通常应优先考虑规范化以确保数据的完整性和一致性，去规范化通常在性能问题出现后才考虑的优化手段</p>
<p>数据库设计过程中，数据库的一致性设计往往以牺牲效率为代价，提高数据库安全性的同时一般也会降低数据库性能</p>
<p>数据文件和索引文件放置在不同磁盘上有利于提高查询效率</p>
<p>提高查询效率：</p>
<p>*索引优化： 为高频过滤条件建立索引，覆盖索引，联合索引的最左前缀原则<br>表结构与查询设计优化： 合理选择数据类型，避免使用select，优化子查询与连接<br>存储结构与硬件优化： 分离数据文件与索引文件，使用RAID或SSD，避免日志与数据文件同盘<br>主要的优化目标是尽量减少查询操作所需的代价，主要包括：</p>
<p>I&#x2F;O代价 与磁盘输入输出操作相关的成本<br>CPU代价 与中央处理器计算和处理相关的成本<br>通信代价：与网络通信相关的成本，包括数据在网络节点之间的传输时间和带宽消耗<br>存储代价：与网存储数据所需的空间相关的成本<br>集中式数据库的查询处理中，主要代价是CPU代价和I&#x2F;O代价。</p>
<p>在分布式数据库系统中，由于数据分布在多个不同的场地上，需要在个站点中传输数据，所以通信代价尤为关键。</p>
<p>如果运行队列数量超过了CPU处理的数目，服务器性能就会受到CPU的限制而下降，解决方法是为服务器适当增加CPU的数量或者是终止需要许多资源的进程</p>
<h3 id="数据库运行维护"><a href="#数据库运行维护" class="headerlink" title="数据库运行维护"></a>数据库运行维护</h3><p>数据库运行维护阶段是指数据库系统正式交付后，数据库系统运行的阶段，其主要任务是保证数据库系统安全、可靠且高校的运行。</p>
<p>维护工作主要包括：</p>
<p>数据库的转储和恢复（确保在数据丢失或损坏时能够恢复数据 ）</p>
<p>数据库的安全性和完整性控制（保障数据的安全和完整 ，如新建数据库用户）</p>
<p>控制数据库性能的监控分析和改进（监控数据库的性能，发现并解决瓶颈问题 ）</p>
<p>数据库的重组和重构 （对数据库进行优化和结构调整 如数据库软件升级）</p>
<p>调整索引，优化查询效率属于数据库性能的改进</p>
<p>数据库重组是指按照系统设计要求对数据库存储空间进行全面调整，如调整磁盘分区方法和存储空间、重新安排数据的存储、整理回收碎块等，以提高数据库性能 。</p>
<p>数据库的重构是指由于数据库应用环境的不断变化，增加了新的应用或新的实体，取消了某些应用，有的实体与实体间的联系也发生了变化等，使得原有的数据库设计不能满足新的需求，此时需要调整数据库的模式和内模式</p>
<p>数据库的重组并不修改数据库原有设计的逻辑结构和物理结构，而数据库的重构则不同，它可以部分修改数据库的模式和内模式</p>
<p>数据库系统运行维护工作的主要目的是保证数据库系统稳定运行，核心任务是直接正对数据库系统本身的优化、监控与安全保障</p>
<p>调整索引属于性能优化范畴，通过索引调整提升查询效率</p>
<p>DBMS补丁安装确保数据库管理系统安全性和功能完善，属于直接维护</p>
<p>检查空间使用 监控数据库存储资源，预防空间不足引发的故障</p>
<p>操作系统补丁安装：属于服务器基础设施维护，通常由系统管理员负责，与数据库系统直接运行无关</p>
<p>数据库系统运行需要依赖服务器、操作系统、存储、网络等多种因素。与RAID5相比，RAID1提高了读速度，加强了系统的可靠性，但是磁盘的利用率低，冗余度高，并且写入速度并未提高。将RAID5改为RAID1，明显是因为要改善读取速度或可靠性才进行了调整，这是根据系统运行性能的优化而做出的调整</p>
<p>根据监控对象的不同，监控分析可以分为两种：</p>
<p>对数据库架构体系的监控<br>主要监控内容：空间基本信息、空间使用率与剩余空间大小、空间是否具有自动扩展的能力、哪些表的扩展将引起空间的扩展，一级段的占用空间与区间数等</p>
<p>对数据库性能的监控<br>主要监控内容：数据缓冲区的命中率、库缓冲、用户锁、锁与等待、回滚段、临时段使用情况、索引的使用情况、等待事件和共享池等</p>
<p>具体来说，监控内容涵盖：</p>
<p>数据库内存使用情况：监控数据库在运行过程中所使用的内存，以确保内存资源得到合理分配何使用<br>数据库中表的空间使用情况：监控数据库表所占用的存储空间，包括表的大小、扩展情况<br>数据库空间使用率：监控数据库的整体存储空间的使用情况，包括已使用和剩余空间<br>数据库CPU使用情况：监控CPU的使用情况，以防止资源耗尽或过载<br>根据监控分析实现的方法不同，监控分析机制分为两种，一种是由数据库系统建立的自动监控机制，另一种是由管理员手动实施的监控机制</p>
<p>索引的使用原则：</p>
<p>经常在查询中作为条件被使用的列，应为其建立索引<br>频繁进行排序或分组的列，应为其建立索引<br>一个列的值域很大时，应为其建立索引<br>如果待排序的列有很多个，建立复合索引<br>使用系统工具来检查索引的完整性，必要时进行修复。另外，当数据库表更新大量数据后，删除并重建索引也可以提高查询速度<br>经常被查询输出的列，仅作为select的输出列。若无where&#x2F;join过滤，索引无法优化查询）<br>建立索引的目的就是为了提高查询效率，查询的性能在很大程度上取决于存在什么样的索引来加快选择和连接的处理。另一方面，在插入、删除或更新操作中，索引的存在又增加了系统的开销。因此，要在加快查询与事务处理效率方面获得好处与增加开销之间进行权衡。当数据库表进行更新大量数据后，删除并重建索引也可以提高查询速度，例如，大部分关系数据库管理系统使用B+树作为索引，如果在索引码上执行大量删除操作，索引页可能会出现空间的浪费，而这些浪费的空间可能需要在重建索引后才能被重用。同样，过多的插入操作也会导致聚簇索引的溢出，这也会影响到性能。</p>
<p>散列索引适用于等值查询，尤其是在连接操作中查找匹配记录时</p>
<p>需要频繁修改的列，每次修改都需要数据库花费一定的性能重建索引，会极大拖累数据库的性能 （不建立索引）</p>
<p>无论B树索引还是非B树索引，在大量删除操作后都会出现空间浪费的问题，需要重新建立索引。</p>
<h2 id="故障管理、备份与恢复"><a href="#故障管理、备份与恢复" class="headerlink" title="故障管理、备份与恢复"></a>故障管理、备份与恢复</h2><p>数据库备份<br>常见的备份类型及共同点：</p>
<p>完整数据库备份：备份特定数据库中的所有数据和相关日志，这是最基础的一种备份方式。完整地记录所有的事务，并将事务日志记录保留到对其备份完毕为止。<br>差异数据库备份：备份自最近的完整备份之后数据库发生的所有变化内容，它基于最近的完整备份，而不是差异备份<br>事务日志备份：备份事务日志文件，已记录自上次备份以来所有的数据库变动。它可以用于恢复到某个特定的时间点。<br>文件组备份：备份数据库的特定文件组，而不是整个数据库。<br>数据转储也被称为数据备份，主要包括静态转储、动态转储、海量转储、增量转储</p>
<p>静态转储：转储过程中不允许对数据库进行任何存取或修改操作。这种方式的恢复过程通常需要借助日志文件<br>日志文件：记录每个事务对数据库的修改操作，主要用于实现数据恢复<br>完全转储：每次转储全部数据，因此占用空间大，但转储速度较慢，恢复过程相对简单<br>动态转储：转储过程中允许对数据库进行存取或修改操作，因此恢复数据时需要使用日志文件。<br>静态转储可以保证数据的有效性，但是却降低数据库的可用性。</p>
<p>动态转储可以提高数据库的可用性，但数据的有效性得不到保证。为了保证数据的一致性，需使用日志文件和动态转储结合使用。在制定备份策略时，需要考虑备份空间、时间等因素。</p>
<p>完全转储是对数据库中所有数据进行转储，此种方式占用较多的时间和空间</p>
<p>差量转储是对最近一次数据库完全转以来发生的数据库变化进行转储。差量转储和完全转储相比速度快，占用空间小；差量转储和增量转储相比速度慢、占用空间多，但是恢复速度快</p>
<p>增量转储只复制上次转储后发生变化的文件或数据块。增量转储所需的时间和空间都比较短，但增量转储数据只能和完全转储配合，才能对数据库进行恢复。增量转储的恢复时间比完全转储要长</p>
<p>对于大型数据库，差异备份的间隔通常比完整数据库备份的时间更短，这可降低数据丢失的风险</p>
<p>静态转储保证看数据的有效性，却是以降低数据库的可用性为代价的</p>
<p>动态转储虽提高了数据库的可用性，但数据的有效性却可能得不到保证。</p>
<p>为了技能保证数据的有效性又不会降低数据库的可用性，需要引入日志文件，用它记录转储期间各种事务对数据库的修改活动记录，然后使用动态转储的备份副本加上日志文件就可以将数据库恢复到某一时刻的正确状态</p>
<p>完全转储是对数据库中所有数据进行转储，需占用较多的时间和空间。转储速度并不快。</p>
<p>对于静态转储，虽然可以建立日志文件，但静态转储本身不依赖于日志文件来恢复数据，因为静态转储是在一个时间点上进行的完全被非，而日志文件主要用于恢复到某个时间点之前的状态，故静态转储恢复过程不一定必须是由日志文件，而其他三种情况（事务故障恢复、系统故障恢复、动态转储）则必须使用日志文件。</p>
<p>备份策略的制定包括定义备份的类型与频率、备份所需硬件的特性和速度、备份的测试方法以及备份媒体的存储位置和方法。在设计良好的备份策略时，要考虑特定业务要求，并尽量提高数据的可用性并减少数据的丢失。</p>
<p>在制定备份策略时，除考虑使用备份恢复时丢失的数据量外，还需要考虑数据库备份所需的时间。</p>
<p>数据库备份可以是磁带也可以是磁盘，数据库备份设备可以为本地设备，也可以使用远程网络设备。</p>
<p>SQL Server支持两种备份方式，一种是先建立备份设备，然后再将数据库备份到备份设备上，这样的备份设备称为永久备份设备；另一种是直接将数据库备份到物理文件上，这样的备份设备称为临时备份设备。</p>
<p>创建备份设备的T-SQL存储过程为sp_addumpdevice</p>
<p>事务日志备份主要用于完整恢复模式和大容量日志恢复模式。</p>
<p>事务日志备份并不备份整个数据库，只备份日志记录，备份自上次备份之后发生变化的日志记录</p>
<p>结尾日志备份在出现故障时进行，用于防止数据丢失，可以包含纯日志记录或者大容量操作日志记录。</p>
<p>仅有完全备份才能够独立灰度数据库，其他备份方法均需要与完全备份配合才能恢复</p>
<p>事务日志备份仅用于完整恢复模式和大容量日志恢复模式</p>
<p>完整数据库备份所需的空间最大</p>
<p>简单恢复模式不备份事务日志，只用于测试和开发数据库，或用于主要包含只读数据的数据库（该模式下数据丢失概率很高）</p>
<p>SQL Server 2008支持数据库、数据文件两个级别的数据恢复。</p>
<p>在restore database语句中使用with recovery选项后，数据库将不能再使用后续备份进行恢复</p>
<p>Tempdb只是一个临时数据库，每次sql server启动时都会重新新建tempdb数据库，除了tempdb数据库之外，其他都需要备份</p>
<p>对于sql server 的系统数据库，一般时在进行了修改之后立即做备份比较合适。比如对master数据库的备份，通常在执行了创建、修改或删除数据库的操作，或是更改了服务器或数据库的配置、建立或更改登录账户等操作后，都应对它进行备份</p>
<p>对于用户数据库应该采用周期性的备份方法，至于多长时间备份一次，与数据的更改频率和用户能够允许的数据丢失多少有关。但在进行了下列操作后，最好能立刻对用户数据库进行备份：</p>
<p>创建数据库之后，或者在数据库中批量加载了数据之后<br>创建索引之后<br>执行力清理事务日志的操作之后<br>执行了大容量 数据操作之后<br>对于用户数据库，简单恢复模式只用于测试和开发数据库，或用于主要包含只读数据库（如数据仓库），这种模式并不适合生产系统，因为对生产系统而言，丢失最新的更改时无法接受的。</p>
<p>数据库的恢复模式决定了事务日志的几率方式和保留时间</p>
<p>完整恢复模式：此模式完整的记录所有事物，并将事务日志保留直至事务备份完毕。这种模式可以进行点时间恢复，能够恢复到某一特定时间点<br>简单恢复模式：此模式也记录所有事务，但事务日志在事务完成后即被截断，不会保留到备份完成。这意味着无法进行点时间恢复，只能恢复到最近的备份点<br>大容量日志恢复模式：此模式对大容量操作进行最小记录，通常作为完整恢复模式的补充，适用于需要进行大量大容量操作的环境。<br>可以用alter database语句对数据库恢复模式进行修改</p>
<p>非介质故障一般只需要执行REDO（重做）和UNDO（回滚）即可</p>
<p>RAID是磁盘级别的，数据写入时自动完成备份，即便数据有问题，也将会在驱动程序的协调下自动完成恢复</p>
<p>使用镜像数据库对数据库进行恢复和使用数据库增量备份对数据库进行恢复是在介质故障时执行的。</p>
<p>RAID1可以避免介质故障带来的影响，RAID0不行</p>
<p>发生软故障后时，需要在重启系统后，undo所有未提交的事务，并redo所有已提交的事务</p>
<p>非预期的事务内部故障可以通过将事务回滚，撤销其对数据库的修改，使数据库回到一致性状态。</p>
<p>数据库故障可以分为事务内部故障、系统故障、介质故障等几种类型：</p>
<p>事务内部故障：<br>非预期的事务内部故障：需要通过回滚（UNDO）操作来恢复，使数据库回到故障发生前的一致性状态<br>可预期的事务内部故障：可以通过事务程序本身进行处理，例如通过回滚操作使数据库达到一致性状态<br>系统故障（软故障）：<br>发生系统故障时，需要通过UNDO队列中各事务的REDO操作来恢复数据库</p>
<p>介质故障：<br>介质故障是最严重的故障，通常无法通过UNDO操作恢复，需要借助备份和恢复机制来避免数据丢失</p>
<p>对于非预期的事务内部故障，在保证该事务对其他事务没有影响的条件下，利用日志文件撤销其对数据库的修改，使数据库恢复到该书屋运行之前的状态，事务故障的恢复是由系统自动完成的，对用户是透明的。</p>
<p>采用硬件容错可以降低介质故障的影响。</p>
<h2 id="大规模数据库架构"><a href="#大规模数据库架构" class="headerlink" title="大规模数据库架构"></a>大规模数据库架构</h2><p>分布式数据库最基本的特征是本地自治、非集中式管理以及高可用性。</p>
<p>本地自治：分布式数据库的最基本特征之一。意味着每个节点能够独立操作，而不依赖于其他节点</p>
<p>非集中式管理：这是分布式数据库的基本特征之一，意味着没有单一的集中管理点，数据，和管理任务分布在多个节点上</p>
<p>高可用性：这是分布式数据库的基本特征之一，意味着系统在出现故障时仍能提供服务，通常通过数据复制和故障转移来实现。</p>
<p>分布式数据库系统的基本概念:</p>
<p>1.全局概念模式:全局概念模式是全局应用的用户视图，即终端用户看到的逻辑上并未分布的表和视图等。</p>
<p>2.查询代价:分布式数据库查询代价不仅需要考虑CPU与I10代价，还需要考虑通信代价等。</p>
<p>3.分布透明性:分布透明性有三个层次，从高到低依次为:</p>
<p>i.分片透明性:最高层次的透明性，用户只需对全局关系进行操作，不必关心数据的分片及存储场地。</p>
<p>i.位置透明性:用户不必知道数据的存储场地即数据分配到哪个或哪些场地存储对用户是透明的。</p>
<p>iii. 局部数据模型透明性:最低层次的透明性，用户需要知道数据的存储结构。</p>
<p>分片透明性&gt;位置透明性&gt;局部透明性</p>
<p>轮转划分：对关系顺序扫描，将第i个元组存储到标号为Dimodn的磁盘上，这种方式保证了元组在多个磁盘上均匀分布</p>
<p>范围划分： 根据表中某个熟悉的取值区间划分成不同的子区间，然后根据表中的属性值属于的不同区间将表分成不同的子表</p>
<p>散列划分：选定一个值域为{0，1，…n-1}的散列函数，对关系中的元组基于划分属性进行散列，如果散列函数返回i，则将其存储到第i个磁盘</p>
<p>多维划分：维是人们观察事物的角度，同样的数据从不同的维进行观察可能会得到不同的结果，如从各个分店的角度，各种商品的角度等，而每个维度又可按力度的不同划分成多个层次。</p>
<p>A. 散列划分<br>就像抽签分座位。每个数据通过一个公式（哈希函数）计算出一个编号，根据编号分配到固定的分区。好处是数据分布均匀，避免某一分区压力过大，但按范围查询时效率可能较低。</p>
<p>B. 轮转划分<br>类似“轮流值班”。新数据依次分配到每个分区，第一个给分区1，第二个给分区2，循环往复。优点是简单公平，每个分区数据量均衡，但无法直接按内容定位数据。</p>
<p>C. 范围划分<br>按顺序分块，比如学生按成绩划分：0-60分在A区，61-80在B区，81-100在C区。适合按范围快速查询（如查“所有90分以上学生”），但若某范围数据过多，可能导致分区负载不均。</p>
<p>D. 多维划分<br>同时考虑多个条件分块。比如超市商品按“类别”和“价格”划分：饮料类且低于5元的分到A区，电器类且高于1000元的分到B区。适合复杂查询（如“找所有亚洲产的电子产品”），但管理更复杂。</p>
<p>散列：均匀但随机。</p>
<p>轮转：绝对平均但无规律。</p>
<p>范围：有序但可能不均衡。</p>
<p>多维：灵活但复杂。</p>
<p>Big Table表的索引是行关键字、列关键字和时间戳，每个单元由行关键字、列关键字和时间戳共同定位。</p>
<p>在Big Table中，不仅可以随意的增删行的数量，同在一定的约束条件下，还可以对列的数量进行扩展。</p>
<p>BigTable数据模型的特点：</p>
<p>表中的行关键字可以是任意字符串<br>列族是由列关键字组成的集合，是访问控制的基本单位<br>时间戳记录了BigTable中每一个数据项所包含的不同版本的数据的时间标识。<br>共享内存结构：所有处理器共享一个公共内存。这种结构的有点事可以方便的交换数据，但随着处理器数量的增加，内存访问冲突和带宽限制会成为瓶颈</p>
<p>共享磁盘结构：每个处理器拥有地理的内存，但共享系统磁盘空间。这种结构解决了内存冲突问题，但处理器之间的通信需要通过网络进行，会产生通信开销</p>
<p>无共享结构：每个处理器拥有独立的内存和磁盘，通过最小化共享资源来降低资源竞争，具有很高的可扩展性。</p>
<p>层次结构：结合了共享内存、共享磁盘和无共享结构的特点，分为两层，顶层是无共享结构，底层是共享内存或共享磁盘结构。</p>
<p>轮转法保证了元组在多个磁盘上平均分配，适合扫描整个关系的应用，负载均衡，并行性好，但是点查询和范围查询效率很低。</p>
<p>散列划分使用散列函数，根据一个或多个属性进行散列，适合点查询，对于顺序扫描也非常高效，但是对散列函数的优劣依赖很大。</p>
<p>范围划分有利于范围查询以及点查询，但是也可能引起数据分布不均匀，导致并行处理能力下降。</p>
<p>XML数据库是一种专门用于存储、管理和查询XML格式文档的数据库。与传统关系型数据库相比，XML数据库具有以下特点和优势:</p>
<p>1.对半结构化数据的有效存取与管理: XML数据库能够很好地处理半结构化数据，这是传统关系型数据库不擅长的。</p>
<p>2.对层次化数据的操作: 由于XML数据格式能够清晰表达数据的层次特征，XML数据库便于对层次化的数据进行操作，</p>
<p>3.支持标签和路径的操作: XML数据库提供对标签和路径的操作，使其在处理XML数据时更加灵活和高效。</p>
<p>4.XML数据处理的实现方式: 现阶段，许多XML数据处理的需求是通过传统关系型数据库厂商在商业产品中扩展XML处理能力来实现的。</p>
<p>云计算是一种通过互联网提供计算资源和服务的商业模型，主要包括三种服务模式:IaaS(基础设施即服务)</p>
<p>PaaS(平台即服务)和SaaS(软件即服务)</p>
<p>1.IaaS(Infrastructure as a Service):基础设施即服务，提供基础的计算资源如虚拟机、存储和网络。</p>
<p>2.PaaS(Platform as a Service):平台即服务，提供一个平台让用户开发、运行和管理应用程序，而不需要自己构建和维护底层基础设施，</p>
<p>3.SaaS(Software as a Service):软件即服务，提供通过互联网访问的软件应用。</p>
<h4 id="数据分片有四种基本方法："><a href="#数据分片有四种基本方法：" class="headerlink" title="数据分片有四种基本方法："></a>数据分片有四种基本方法：</h4><p>1、水平分片是在关系中从行的角度（元组）依据一定条件划分为不同的片断，关系中的每一行必须至少属于一个片断，以便在需要时可以重构关系。</p>
<p>2、垂直分片是在关系中从列的角度（属性）依据一定条件分为不同的片断，各片断中应该包含关系的主码属性，以便通过连接方法恢复关系。</p>
<p>3、导出分片是导出水平分片，分片的依据不是本关系属性的条件，而是其他关系属性的条件。</p>
<p>4、混合分片指以上三种方法的混合。</p>
<p>并行数据库中的数据划分与并行算法的相关知识:</p>
<p>1.聚集函数SUM、MIN、MAX的计算一般都可以通过“先分后合”的方式实现并行化。聚集函数如SUM、MIN、MAX可以通过将数据分成多个部分，分别计算每个部分的结果，然后再将这些部分的结果合并，从而实现并行化处理。</p>
<p>2.如果关系按照范围划分的方法进行划分，且排序属性恰好为划分属性，则可以直接将各个划分的排序结果串接起来，得到完全排好序的关系。范围划分是一种数据划分方法，如果排序属性与划分属性一致，可以将各个划分的排序结果直接串接起来得到完全排好序的关系。</p>
<p>3.范围划分可以确保数据分布的均匀性，保证系统的并行处理能力。范围划分可能会导致数据分布不均匀，因为数据在不同范围内的分布可能不均衡，从而影响并行处理能力。</p>
<p>4.用轮转法对数据进行划分最适合干需扫描整个关系的应用，对这种应用可以更好地实现负载均衡，充分发挥并行性。轮转法是一种数据划分方法，适用于需要扫描整个关系的应用，可以实现较好的负载均衡。</p>
<p>并行数据库系统通过多个处理器并行处理数据，以提高数据库的性能和处理能力。根据不同的资源共享方式，并行数据库系统可以分为几种不同的结构类型，包括共享内存结构、共享磁盘结构和无共享结构等。</p>
<p>1.共享内存结构:在这种结构中，所有处理器共享一个公共的内存空间，处理器之间通过内存进行通信和数据交换。</p>
<p>2.共享磁盘结构:在这种结构中，处理器之间共享存储设备，但不共享内存。</p>
<p>3.无共享结构:在这种结构中，每个处理器有独立的内存和存储资源，通过网络进行通信，以减少资源竞争和冲突。</p>
<p>常见的一维数据划分方法包括轮转法、散列划分和范围划分:</p>
<p>1.轮转法(Round-Robin Partitioning):数据按某一属性值进行循环分配到各个节点，适用干扫描整个关系的应用。</p>
<p>2.散列划分(Hash Partitioning):通过散列函数将数据分配到不同节点，适用干点查询的应用。</p>
<p>5.范围划分(Range Partitioning):将数据根据某一属性值的范围分配到不同节点，适合干范围查询的应用。</p>
<p>在分布式数据库中，查询处理和优化比集中式数据库要复杂得多，主要原因在于分布式数据库需要考虑多个节点之间的数据传输和协调。查询优化需要综合考虑I10代价、CPU代价和通信代价三个主要因素。</p>
<p>其中，通信代价在分布式数据库中尤为重要，原因如下:</p>
<p>1.通信代价较I10代价更容易估计，</p>
<p>2.分布式数据库环境下，节点间的通信成本(包括网络延迟、数据传输量等)对查询性能的影响更为显著。</p>
<p>3.通信代价直接影响到查询的响应时间和整体效率，因此在优化过程中通常优先考虑降低通信代价。</p>
<h2 id="数据仓库与数据挖掘"><a href="#数据仓库与数据挖掘" class="headerlink" title="数据仓库与数据挖掘"></a>数据仓库与数据挖掘</h2><ol>
<li>数据仓库 :</li>
</ol>
<p>i.数据仓库是一个面向主题、集成的、非易失的、且随时间变化的数据集合，用来支持管理人员决策。</p>
<ol start="2">
<li>决策支持系统 :</li>
</ol>
<p>i.决策支持系统是辅助决策者通过数据、模型和知识，以人机交互方式进行半结构化或非结构化决策的计算机应用系统</p>
<ol start="3">
<li>数据挖掘</li>
</ol>
<p>i.数据挖掘是从大量数据中自动发现隐藏的、有价值的模式或知识的过程。它是从人工智能和机器学习中发展起来的。</p>
<p>因为数据挖掘不仅仅是数据分析师根据个人经验针对细节数据进行分析总结的过程，而是一个自动从大量数据中挖掘出模式和知识的过程。</p>
<p>4.机器学习:</p>
<p>I.机器学习是研究使计算机模拟或实现人类的学习行为，即让计算机自动获取知识</p>
<p>数据仓库是一个用干分析和报告的大型数据库系统，其设计目的是支持管理决策，与传统的事务处理系统(如OLTP)不同，数据仓库具有以下几个显著特点：</p>
<p>1.面向主题:数据仓库的数据是按主题进行组织的，而不是按应用程序组织。主题是一个高层次的抽象，通常对应干企业的一个业务领域，如销售、库存等。数据仓库中的数据来自多个异构数据源，经过清洗、转换后按照特定主题进行整合。</p>
<p>2.只读性:数据仓库中的数据通常是只读的，主要用干查询和分析，不支持直接修改。数据仓库的数据一旦加载后，不会频繁更新，只在定期加载新数据时进行增量更新或完全刷新。</p>
<p>3.批量访问:数据仓库中的数据访问通常是批量的，通过复杂的查询和分析操作进行，而不是单个记录的读写操作。数据仓库系统通过批量处理来优化查询性能。</p>
<p>4.高可用性:尽管数据仓库的数据访问频率较低但对数据的可用性要求较高，需要保证数据的完整性和一致性，以支持决策支持系统(DSS)的高效运行。</p>
<p>5.历史数据:数据仓库中存储的数据通常包含历史信息，以支持对历史数据的分析和趋势分析。</p>
<p>（性能要求：OLTP性能要求高）</p>
<p>数据仓库是用于支持企业决策的数据集合，其主要特征包括以下几个方面:</p>
<p>1.集成的:数据仓库中的数据来自多个异构数据源，经过清洗、转换和整合，形成一个统一的、综合的数据集合，便于分析和查询。</p>
<p>2.随时间变化:数据仓库中的数据通常包含时间维度，记录了历史数据，能够反映数据随时间的变化情况，用千分析历史趋势和变化。</p>
<p>5.面向主题:数据仓库中的数据是按照特定的业务主题组织的，而不是按照应用程序组织，便干进行决策分析。</p>
<p>4.不可修改:数据仓库中的数据通常是只读的，主要用干查询和分析，不用于日常事务处理，因此数据一旦进入数据仓库后，一般不进行修改。</p>
<p>建立数据仓库的主要目的在于根据决策需求对企业的数据采取适当的手段进行集成，形成一个综合的、面向分析的数据环境，用于支持企业的信息型、决策型的分析应用。</p>
<p>数据粒度是指数据的细化程度或详细程度，粒度越小，数据越详细，数据量越大，粒度越大，数据越综合。在数据分析和数据仓库中，粒度是一个非常重要的概念，它决定了数据的详细程度和数据量的大小。一般来说，粒度越小的数据包含的信息越多，粒度越大的数据包含的信息越少。粒度的大小直接影响到数据的查询性能和分析能力。</p>
<p>数据仓库是服务干决策支持的数据集合。</p>
<p>数据仓库是一个面向主题、集成的、非易失的、且随时间变化的数据集合，用来支持管理人员的决策。</p>
<p>决策支持系统是指辅助需要决策的人或系统进行决策的系统。</p>
<p>i.决策支持系统(DSS)是辅助决策者通过数据、模型和知识，以人机交互方式进行半结构化或非结构化决策的计算机应用系统。</p>
<p>机器学习是指机器采用一些方法或模型从数据中习得知识的过程。</p>
<p>i.机器学习是研究使计算机模拟或实现人类的学习行为，即让计算机自动获取知识。</p>
<p>数据挖掘是从数据库中的所有数据记录中归纳总结出知识，让人们从抽象复杂的数据中看到客观规律，以便做出决策。它不仅仅是数据分析师根据个人经验进行分析，而是使用各种算法和技术来从大量数据中挖掘出有用的信息和知识。</p>
<p>元数据(Metadata)是描述其他数据的数据，用于提供有关信息资源的结构化数据，其目的是识别、评价、追踪资源的变化以及实现对信息资源的有效管理和查找。元数据可以分为技术元数据和业务元数据。</p>
<p>1.技术元数据:描述数据的结构、存储位置、访问路径等技术信息，如数据字典、数据库模式等。</p>
<p>2.业务元数据:描述数据的业务含义、用途、关系等，如数据的业务定义、数据的业务规则等。</p>
<p>ETL是英文Extraet-Trans,formLoad的缩写,用来描述将数据从来源端经过抽取(extract)、转换(transform)、加载(load)至目的端的过程。采用数据抽取程序从OLTP系统中抽取数据的主要原因是解决不同类型应用程序之间的性能冲突问题。</p>
<p>数据集成是将源自不同数据源的数据经过抽取、转换、清理、装载等操作载入数据仓库的过程，是实施数据仓库的重要步骤。由于对大量的原始数据要加以提炼，要减轻分析工作给处理业务数据的服务器带来的压力，要规范各源数据，以及要处理那些难以直接使用的数据，数据集成在数据仓库设计中是必不可少的一环，ETL是实现数据集成的主要技术。</p>
<p>分类算法用干将数据分为预定义的类别，而聚类算法则用干将数据分组，不依赖干预定义的类别。</p>
<p>1.SVM(支持向量机)算法:是一种常用的分类算法，通过找到一个超平面将数据分隔开来属千分类算法。</p>
<p>2.BP神经网络算法:是一种通过反向传播算法进行训练的神经网络方法，也用于分类任务。</p>
<p>3.决策树算法:是一种通过树形结构进行分类和回归的算法，属子分类算法。</p>
<p>4.K-means算法:是一种聚类算法，用于将数据分成K个簇，不属于分类算法。</p>
<p>快照是关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的映像。快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品，它反映的是某个时间点内的数据，该数据具有不可改变性，商场商品销售表、电信公司通话详单属于动态数据，不适合用快照的方式获取数据。</p>
<p>快照方式是指获取数据源在某个时间点的完整拷贝，通常用于静态或变化较慢的数据表，以便在数据仓库中保存该时间点的数据状态。</p>
<p>机器学习主要分为有监督学习、无监督学习和强化学习</p>
<p>有监督学习：通过已标记的样本数据（即已知输入和输出）来训练模型，以便对新数据进行分类或回归分析。例如，根据样本数据训练分类器和进行回归分析都属于有监督学习，因为这些人物需要已知的标签或目标来指导模型的学习过程<br>无监督学习：不依赖于已标记的数据，而是通过数据的内在结构来发现模式。聚类方法是无监督学习的一种典型应用，它将未知类别的数据分成不同的组，不需要预先知道每个数据点的类别标签，而是通过算法自动将类似的数据分到同一组中。聚类方法包括统计方法、机器学习方法、神经网络方法和面向数据库的方法等。<br>强化学习：通过与环境的交互，学习如何采取行动以最大化某种奖励信号，通常用于训练机器人在动态环境中自主学习。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hrb802.github.io">Brihen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hrb802.github.io/post/cdfd3d36.html">https://hrb802.github.io/post/cdfd3d36.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://hrb802.github.io" target="_blank">灯三千的个人小天地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post-share"><div class="social-share" data-image="/img/Chuyin.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/ProfilePic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Brihen</div><div class="author-info-description">来自天堂的咸鱼</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hrb802"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/hrb802" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2844760252@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这里是灯三千/Brihen的个人小天地，用来分享学习、生活、感悟、思考等，不定时更新。如遇到什么问题请联系作者哦。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">数据库分析与设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDEF0%E9%9C%80%E6%B1%82%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">IDEF0需求建模方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.</span> <span class="toc-text">物理结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.</span> <span class="toc-text">逻辑结构设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="toc-number">2.1.</span> <span class="toc-text">完整性约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UML%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F-UML%EF%BC%88%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">UML与数据库应用系统 UML（统一建模语言）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.</span> <span class="toc-text">高级查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E5%8C%BA%E5%87%BD%E6%95%B0%E7%9A%84sql%E8%AF%AD%E5%8F%A5%E6%98%AF%EF%BC%9A"><span class="toc-number">4.0.1.</span> <span class="toc-text">创建分区函数的sql语句是：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8E%E5%8F%B0%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF"><span class="toc-number">5.</span> <span class="toc-text">数据库后台编程技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">数据库及数据库对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA"><span class="toc-number">6.1.</span> <span class="toc-text">分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">6.2.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">6.3.</span> <span class="toc-text">日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">安全管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%B4%E6%8A%A4%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">运行维护与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96"><span class="toc-number">8.1.</span> <span class="toc-text">数据库优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2"><span class="toc-number">8.2.</span> <span class="toc-text">分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E8%A1%8C%E7%BB%B4%E6%8A%A4"><span class="toc-number">8.3.</span> <span class="toc-text">数据库运行维护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E7%AE%A1%E7%90%86%E3%80%81%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-number">9.</span> <span class="toc-text">故障管理、备份与恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84"><span class="toc-number">10.</span> <span class="toc-text">大规模数据库架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E6%9C%89%E5%9B%9B%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">10.0.1.</span> <span class="toc-text">数据分片有四种基本方法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98"><span class="toc-number">11.</span> <span class="toc-text">数据仓库与数据挖掘</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/6.html" title="CSS三大特性"><img src="/img/t01d3d7d1e12b380e02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS三大特性"/></a><div class="content"><a class="title" href="/post/6.html" title="CSS三大特性">CSS三大特性</a><time datetime="2025-08-20T09:34:26.000Z" title="发表于 2025-08-20 17:34:26">2025-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/5.html" title="HTML基础标签与CSS样式（一）"><img src="/img/Lanbo3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTML基础标签与CSS样式（一）"/></a><div class="content"><a class="title" href="/post/5.html" title="HTML基础标签与CSS样式（一）">HTML基础标签与CSS样式（一）</a><time datetime="2025-08-16T10:00:46.000Z" title="发表于 2025-08-16 18:00:46">2025-08-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/4.html" title="计算机网络——网络通信的五层模型"><img src="/img/Luotianyi.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络——网络通信的五层模型"/></a><div class="content"><a class="title" href="/post/4.html" title="计算机网络——网络通信的五层模型">计算机网络——网络通信的五层模型</a><time datetime="2025-07-28T06:52:25.000Z" title="发表于 2025-07-28 14:52:25">2025-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/3.html" title="Hexo创建博客的front-matter内容详细信息（基本元数据配置）"><img src="/img/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo创建博客的front-matter内容详细信息（基本元数据配置）"/></a><div class="content"><a class="title" href="/post/3.html" title="Hexo创建博客的front-matter内容详细信息（基本元数据配置）">Hexo创建博客的front-matter内容详细信息（基本元数据配置）</a><time datetime="2025-07-25T01:11:21.000Z" title="发表于 2025-07-25 09:11:21">2025-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/cdfd3d36.html" title="计算机数据库（个人备考）"><img src="/img/Chuyin.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机数据库（个人备考）"/></a><div class="content"><a class="title" href="/post/cdfd3d36.html" title="计算机数据库（个人备考）">计算机数据库（个人备考）</a><time datetime="2025-06-22T08:04:14.000Z" title="发表于 2025-06-22 16:04:14">2025-06-22</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Brihen</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b2</a></span></div><div class="footer_custom_text">如遇到什么问题或建议，请联系作者，天官赐福，百无禁忌。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: '',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script data-pjax defer src="https://npm.elemecdn.com/tzy-blog/lib/js/theme/chocolate.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/bangumi/"]):not([href="/Gallery/"]):not([href="/books/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>